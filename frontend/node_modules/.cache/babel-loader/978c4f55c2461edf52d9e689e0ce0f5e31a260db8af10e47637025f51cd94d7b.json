{"ast":null,"code":"import axios from 'axios';\nimport { getCurrentUser, saveUser, removeUser, setupTokenExpiryTimer, updateToken } from '../utils/tokenUtils';\nimport api from './api';\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8080/api';\n\n// Данные для отслеживания состояния сессии\nconst sessionState = {\n  lastAuth: 0,\n  refreshing: false\n};\nclass AuthService {\n  async login(username, password) {\n    console.log('Attempting login for user:', username);\n    try {\n      const response = await axios.post(`${API_URL}/auth/signin`, {\n        username,\n        password,\n        // Добавляем текущее время к запросу для снижения вероятности кэширования\n        _t: Date.now()\n      });\n      console.log('Login response received:', response.status);\n      if (response.data.accessToken) {\n        console.log('Access token received, saving user data');\n        console.log('Token:', response.data.accessToken.substring(0, 20) + '...');\n\n        // Получаем время жизни токена из ответа или используем значение по умолчанию\n        const tokenExpiry = response.data.tokenExpiry || 7200;\n        console.log(`Token expiry set to ${tokenExpiry} seconds`);\n\n        // Записываем время последнего получения токена\n        sessionState.lastAuth = Date.now();\n        sessionState.tokenExpiry = Date.now() + tokenExpiry * 1000;\n\n        // Сохраняем пользователя в localStorage\n        saveUser(response.data);\n      } else {\n        console.log('No access token in response');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Login error:', error.message);\n      if (error.response) {\n        console.error('Server response data:', error.response.data);\n      }\n      throw error;\n    }\n  }\n  async refreshToken() {\n    try {\n      // Проверяем, не выполняется ли уже обновление токена\n      if (sessionState.refreshing) {\n        console.log('Token refresh already in progress');\n        return null;\n      }\n      sessionState.refreshing = true;\n      console.log('Refreshing token...');\n\n      // Получаем текущий токен\n      const user = getCurrentUser();\n      if (!user || !user.accessToken) {\n        console.log('No token available to refresh');\n        sessionState.refreshing = false;\n        return null;\n      }\n\n      // Отправляем запрос на обновление токена\n      const response = await api.post(`/auth/refresh-token`, {\n        refreshToken: 'refresh' // Используется только для валидации запроса\n      });\n      console.log('Token refresh response received');\n      if (response.data && response.data.accessToken) {\n        console.log('New access token received');\n\n        // Обновляем токен в localStorage\n        const success = updateToken(response.data.accessToken, response.data.tokenExpiry);\n        if (success) {\n          console.log('Token refreshed successfully');\n          sessionState.lastAuth = Date.now();\n          sessionState.refreshing = false;\n          return response.data.accessToken;\n        }\n      }\n      sessionState.refreshing = false;\n      return null;\n    } catch (error) {\n      console.error('Token refresh error:', error.message);\n      if (error.response) {\n        console.error('Server response data:', error.response.data);\n      }\n      sessionState.refreshing = false;\n\n      // Если обновление токена не удалось из-за ошибки авторизации, выполняем выход\n      if (error.response && (error.response.status === 401 || error.response.status === 403)) {\n        console.log('Authentication error during token refresh, logging out');\n        this.logout();\n      }\n      return null;\n    }\n  }\n  logout() {\n    console.log('Logging out user');\n    removeUser();\n    // Сбрасываем состояние сессии\n    sessionState.lastAuth = 0;\n    sessionState.refreshing = false;\n  }\n  register(userData) {\n    return axios.post(`${API_URL}/auth/signup`, userData);\n  }\n  getCurrentUser() {\n    const user = getCurrentUser();\n    console.log('Getting current user:', user ? `${user.username} (ID: ${user.id})` : 'No user found');\n    if (user) {\n      console.log('User has token:', !!user.accessToken);\n    }\n    return user;\n  }\n  getAuthHeader() {\n    const user = this.getCurrentUser();\n    if (user && user.accessToken) {\n      // Ensure the token is properly formatted\n      return {\n        'x-access-token': user.accessToken\n      };\n    } else {\n      return {};\n    }\n  }\n\n  // Метод для проверки токена\n  async checkToken() {\n    try {\n      console.log('Checking token validity...');\n\n      // Проверяем, есть ли токен вообще\n      const user = getCurrentUser();\n      if (!user || !user.accessToken) {\n        console.log('No token available to check');\n        return {\n          valid: false,\n          error: 'no_token'\n        };\n      }\n\n      // Добавляем текущее время, чтобы избежать кэширования\n      const response = await api.get(`/debug/check-token?t=${Date.now()}`);\n      console.log('Token check response:', response.data);\n\n      // Если токен валиден, запускаем таймер проверки истечения\n      if (response.data && response.data.message === 'Токен действителен') {\n        setupTokenExpiryTimer();\n      }\n      return {\n        valid: true,\n        data: response.data\n      };\n    } catch (error) {\n      console.error('Token check failed:', error.message);\n\n      // If error is due to unauthorized or token expiration\n      if (error.response && (error.response.status === 401 || error.response.status === 403)) {\n        console.log('Token is invalid or expired');\n        // Clear the invalid token\n        removeUser();\n      }\n      return {\n        valid: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Метод для проверки срока сессии\n  isSessionValid() {\n    const user = getCurrentUser();\n    if (!user || !user.accessToken) {\n      return false;\n    }\n\n    // Если прошло более 2 часов с момента входа, считаем сессию недействительной\n    const sessionDuration = 2 * 60 * 60 * 1000; // 2 часа\n    const now = Date.now();\n    const sessionElapsed = now - sessionState.lastAuth;\n    return sessionState.lastAuth > 0 && sessionElapsed < sessionDuration;\n  }\n}\nconst authService = new AuthService();\nexport default authService;","map":{"version":3,"names":["axios","getCurrentUser","saveUser","removeUser","setupTokenExpiryTimer","updateToken","api","API_URL","process","env","REACT_APP_API_URL","sessionState","lastAuth","refreshing","AuthService","login","username","password","console","log","response","post","_t","Date","now","status","data","accessToken","substring","tokenExpiry","error","message","refreshToken","user","success","logout","register","userData","id","getAuthHeader","checkToken","valid","get","isSessionValid","sessionDuration","sessionElapsed","authService"],"sources":["C:/Users/Masha/Desktop/KP/frontend/src/services/auth.service.js"],"sourcesContent":["import axios from 'axios';\nimport { getCurrentUser, saveUser, removeUser, setupTokenExpiryTimer, updateToken } from '../utils/tokenUtils';\nimport api from './api';\n\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8080/api';\n\n// Данные для отслеживания состояния сессии\nconst sessionState = {\n  lastAuth: 0,\n  refreshing: false\n};\n\nclass AuthService {\n  async login(username, password) {\n    console.log('Attempting login for user:', username);\n    try {\n      const response = await axios.post(`${API_URL}/auth/signin`, { \n        username, \n        password,\n        // Добавляем текущее время к запросу для снижения вероятности кэширования\n        _t: Date.now()\n      });\n      console.log('Login response received:', response.status);\n      \n      if (response.data.accessToken) {\n        console.log('Access token received, saving user data');\n        console.log('Token:', response.data.accessToken.substring(0, 20) + '...');\n        \n        // Получаем время жизни токена из ответа или используем значение по умолчанию\n        const tokenExpiry = response.data.tokenExpiry || 7200;\n        console.log(`Token expiry set to ${tokenExpiry} seconds`);\n        \n        // Записываем время последнего получения токена\n        sessionState.lastAuth = Date.now();\n        sessionState.tokenExpiry = Date.now() + (tokenExpiry * 1000);\n        \n        // Сохраняем пользователя в localStorage\n        saveUser(response.data);\n      } else {\n        console.log('No access token in response');\n      }\n      return response.data;\n    } catch (error) {\n      console.error('Login error:', error.message);\n      if (error.response) {\n        console.error('Server response data:', error.response.data);\n      }\n      throw error;\n    }\n  }\n\n  async refreshToken() {\n    try {\n      // Проверяем, не выполняется ли уже обновление токена\n      if (sessionState.refreshing) {\n        console.log('Token refresh already in progress');\n        return null;\n      }\n      \n      sessionState.refreshing = true;\n      console.log('Refreshing token...');\n      \n      // Получаем текущий токен\n      const user = getCurrentUser();\n      if (!user || !user.accessToken) {\n        console.log('No token available to refresh');\n        sessionState.refreshing = false;\n        return null;\n      }\n      \n      // Отправляем запрос на обновление токена\n      const response = await api.post(`/auth/refresh-token`, { \n        refreshToken: 'refresh' // Используется только для валидации запроса\n      });\n      \n      console.log('Token refresh response received');\n      \n      if (response.data && response.data.accessToken) {\n        console.log('New access token received');\n        \n        // Обновляем токен в localStorage\n        const success = updateToken(\n          response.data.accessToken, \n          response.data.tokenExpiry\n        );\n        \n        if (success) {\n          console.log('Token refreshed successfully');\n          sessionState.lastAuth = Date.now();\n          sessionState.refreshing = false;\n          return response.data.accessToken;\n        }\n      }\n      \n      sessionState.refreshing = false;\n      return null;\n    } catch (error) {\n      console.error('Token refresh error:', error.message);\n      if (error.response) {\n        console.error('Server response data:', error.response.data);\n      }\n      \n      sessionState.refreshing = false;\n      \n      // Если обновление токена не удалось из-за ошибки авторизации, выполняем выход\n      if (error.response && (error.response.status === 401 || error.response.status === 403)) {\n        console.log('Authentication error during token refresh, logging out');\n        this.logout();\n      }\n      \n      return null;\n    }\n  }\n\n  logout() {\n    console.log('Logging out user');\n    removeUser();\n    // Сбрасываем состояние сессии\n    sessionState.lastAuth = 0;\n    sessionState.refreshing = false;\n  }\n\n  register(userData) {\n    return axios.post(`${API_URL}/auth/signup`, userData);\n  }\n\n  getCurrentUser() {\n    const user = getCurrentUser();\n    console.log('Getting current user:', user ? `${user.username} (ID: ${user.id})` : 'No user found');\n    if (user) {\n      console.log('User has token:', !!user.accessToken);\n    }\n    return user;\n  }\n\n  getAuthHeader() {\n    const user = this.getCurrentUser();\n    if (user && user.accessToken) {\n      // Ensure the token is properly formatted\n      return { 'x-access-token': user.accessToken };\n    } else {\n      return {};\n    }\n  }\n  \n  // Метод для проверки токена\n  async checkToken() {\n    try {\n      console.log('Checking token validity...');\n      \n      // Проверяем, есть ли токен вообще\n      const user = getCurrentUser();\n      if (!user || !user.accessToken) {\n        console.log('No token available to check');\n        return { valid: false, error: 'no_token' };\n      }\n      \n      // Добавляем текущее время, чтобы избежать кэширования\n      const response = await api.get(`/debug/check-token?t=${Date.now()}`);\n      console.log('Token check response:', response.data);\n      \n      // Если токен валиден, запускаем таймер проверки истечения\n      if (response.data && response.data.message === 'Токен действителен') {\n        setupTokenExpiryTimer();\n      }\n      \n      return { valid: true, data: response.data };\n    } catch (error) {\n      console.error('Token check failed:', error.message);\n      \n      // If error is due to unauthorized or token expiration\n      if (error.response && (error.response.status === 401 || error.response.status === 403)) {\n        console.log('Token is invalid or expired');\n        // Clear the invalid token\n        removeUser();\n      }\n      \n      return { valid: false, error: error.message };\n    }\n  }\n  \n  // Метод для проверки срока сессии\n  isSessionValid() {\n    const user = getCurrentUser();\n    if (!user || !user.accessToken) {\n      return false;\n    }\n    \n    // Если прошло более 2 часов с момента входа, считаем сессию недействительной\n    const sessionDuration = 2 * 60 * 60 * 1000; // 2 часа\n    const now = Date.now();\n    const sessionElapsed = now - sessionState.lastAuth;\n    \n    return sessionState.lastAuth > 0 && sessionElapsed < sessionDuration;\n  }\n}\n\nconst authService = new AuthService();\nexport default authService; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}